<!-- নতুন: socket.io ক্লায়েন্ট লোড (server.js যদি socket.io সার্ভ করে) -->
<script src="/socket.io/socket.io.js"></script>

<script>
  const listEl = document.getElementById('list');
  const emptyEl = document.getElementById('empty');
  const state = new Map(); // id -> record

  function setEmpty() { emptyEl.style.display = state.size ? 'none' : 'block'; }

  function escapeHtml(s) {
    return String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
  }

  // deterministic color from string
  function colorFromString(s) {
    let hash = 0;
    for (let i = 0; i < s.length; i++) {
      hash = s.charCodeAt(i) + ((hash << 5) - hash);
      hash = hash & hash;
    }
    const hue = Math.abs(hash) % 360;
    return `hsl(${hue},70%,50%)`;
  }

  function cardTpl(rec) {
    const wrap = document.createElement('div');
    wrap.className = 'card';
    wrap.id = `msg-${rec.id}`;

    const timeText = escapeHtml(rec.parts.time || '');
    const toText = escapeHtml(rec.parts.to || '');
    const msgText = escapeHtml(rec.parts.text || '');

    wrap.innerHTML = `
      <div>
        <div class="meta row"><strong>time:</strong> ${timeText}</div>
        <div class="meta row"><strong>to:</strong> <span class="to-number" data-to="${toText}">${toText}</span></div>
        <div class="text"><strong>text:</strong> ${msgText}</div>
      </div>
      <div>
        <button class="btn-del" data-id="${rec.id}" title="Delete this message">Delete</button>
      </div>
    `;

    const toEl = wrap.querySelector('.to-number');
    if (toEl) {
      toEl.style.color = colorFromString(rec.parts.to || rec.parts.text || String(rec.id));
    }

    wrap.querySelector('.btn-del').addEventListener('click', async (e) => {
      const id = e.currentTarget.getAttribute('data-id');
      // try multiple delete endpoints (best-effort)
      const tryList = [
        { url: `/api/messages/${id}`, opts: { method: 'DELETE' } },
        { url: `/sms`, opts: { method: 'DELETE' } },
        { url: `/sms/delete`, opts: { method: 'POST' } }
      ];
      for (const attempt of tryList) {
        try {
          const resp = await fetch(attempt.url, attempt.opts);
          if (resp.ok) {
            // optimistic remove on success
            removeCard(id);
            return;
          }
        } catch (err) { /* ignore and try next */ }
      }
      console.warn('Delete attempts failed for', id);
    });

    return wrap;
  }

  function addTop(rec) {
    // ensure unique id
    if (!rec.id) rec.id = String(Date.now()) + Math.floor(Math.random()*1000);
    state.set(rec.id, rec);
    const el = cardTpl(rec);
    if (listEl.firstChild) listEl.insertBefore(el, listEl.firstChild);
    else listEl.appendChild(el);
    setEmpty();
  }

  function removeCard(id) {
    state.delete(id);
    const el = document.getElementById(`msg-${id}`);
    if (el) el.remove();
    setEmpty();
  }

  // Normalize many possible server payloads into { id, parts: {time,to,text} }
  function normalizeAndAdd(raw) {
    if (!raw) return;
    // If the payload already matches our rec shape (has parts)
    if (raw.parts && (raw.parts.text || raw.parts.time || raw.parts.to)) {
      const rec = { id: raw.id || raw.parts.id || String(Date.now()), parts: raw.parts };
      addTop(rec);
      return;
    }
    // Common alternative shapes:
    // { message, timestamp, expiresAt, to }
    const text = raw.message || raw.text || raw.msg || (raw.data && raw.data.text) || '';
    const time = raw.timestamp || raw.time || raw.ts || raw.expiresAt || (raw.data && raw.data.time) || new Date().toISOString();
    const to = raw.to || raw.from || (raw.data && raw.data.to) || '';
    const id = raw.id || raw.timestamp || raw.ts || String(Date.now()) + Math.floor(Math.random()*1000);
    addTop({ id: String(id), parts: { time, to, text } });
  }

  // --- Try SSE (EventSource) first: keeps original behavior if your backend supports it ---
  function bootSSE() {
    try {
      const es = new EventSource('/events');
      es.onmessage = (ev) => {
        try {
          const payload = JSON.parse(ev.data);
          // legacy payload pattern: { type:'init'|'new'|'delete', data: [...] }
          if (payload && payload.type === 'init' && Array.isArray(payload.data)) {
            for (const rec of payload.data.slice().reverse()) normalizeAndAdd(rec);
          } else if (payload && payload.type === 'new') {
            normalizeAndAdd(payload.data);
          } else if (payload && payload.type === 'delete') {
            if (payload.id) removeCard(payload.id);
            else {
              // remove all if no id given
              for (const id of Array.from(state.keys())) removeCard(id);
            }
          } else {
            // fallback: plain message object
            normalizeAndAdd(payload);
          }
        } catch (e) { console.warn('SSE parse', e); }
      };
      es.onerror = () => console.warn('SSE disconnected or not available');
    } catch (e) {
      console.warn('SSE not supported', e);
    }
  }

  // --- Try Socket.IO if available on server ---
  function bootSocketIO() {
    if (typeof io === 'undefined') return;
    try {
      const socket = io(); // connect to server
      socket.on('connect', () => console.log('socket.io connected'));
      socket.on('newMessage', (payload) => {
        normalizeAndAdd(payload);
      });
      // server used 'messageDeleted' in your provided server.js
      socket.on('messageDeleted', (payload) => {
        if (payload && payload.id) removeCard(payload.id);
        else {
          for (const id of Array.from(state.keys())) removeCard(id);
        }
      });
      // some servers might emit generic events
      socket.on('disconnect', () => console.warn('socket.io disconnected'));
    } catch (e) { console.warn('socket.io boot failed', e); }
  }

  // --- As a last resort, try fetching an API list (if server exposes /api/messages) ---
  async function bootFetch() {
    try {
      const res = await fetch('/api/messages');
      if (!res.ok) return;
      const arr = await res.json();
      if (Array.isArray(arr)) {
        for (const rec of arr.slice().reverse()) normalizeAndAdd(rec);
      } else if (arr) {
        normalizeAndAdd(arr);
      }
    } catch (e) { /* ignore failure */ }
  }

  // Start everything (will harmlessly try all available transports)
  bootFetch();
  bootSSE();
  bootSocketIO();
</script>

